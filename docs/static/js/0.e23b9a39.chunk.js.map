{"version":3,"sources":["../node_modules/highlight.js/lib/highlight.js","../node_modules/highlight.js/lib/languages/javascript.js","../node_modules/highlight.js/lib/languages/less.js","../node_modules/highlight.js/lib/languages/xml.js","../node_modules/marked/lib/marked.js"],"names":["factory","window","self","hljs","API_REPLACES","ArrayProto","objectKeys","Object","keys","languages","aliases","noHighlightRe","languagePrefixRe","fixMarkupRe","spanEndTag","options","classPrefix","tabReplace","useBR","undefined","escape","value","replace","tag","node","nodeName","toLowerCase","testRe","re","lexeme","match","exec","index","isNotHighlighted","language","test","inherit","parent","key","result","objects","Array","prototype","slice","call","arguments","forEach","obj","nodeStream","_nodeStream","offset","child","firstChild","nextSibling","nodeType","nodeValue","length","push","event","restoreLanguageApi","langApiRestored","contains","concat","variants","compileLanguage","reStr","source","langRe","global","RegExp","case_insensitive","compileMode","mode","compiled","keywords","beginKeywords","compiled_keywords","flatten","className","str","split","kw","pair","Number","lexemesRe","lexemes","begin","join","beginRe","endSameAsBegin","end","endsWithParent","endRe","terminator_end","illegal","illegalRe","relevance","apply","map","c","cached_variants","variant","expand_mode","starts","terminators","filter","Boolean","regexps","separator","backreferenceRe","numCaptures","ret","i","substring","String","joinRe","highlight","name","ignore_illegals","continuation","keywordMatch","match_str","hasOwnProperty","buildSpan","classname","insideSpan","leaveOpen","noPrefix","openSpan","closeSpan","processBuffer","top","subLanguage","explicit","mode_buffer","continuations","highlightAuto","processSubLanguage","keyword_match","last_index","lastIndex","substr","processKeywords","startNewMode","create","processLexeme","buffer","new_mode","subMode","skip","excludeBegin","returnBegin","end_mode","endOfMode","endsParent","origin","returnEnd","excludeEnd","isIllegal","Error","getLanguage","current","count","e","message","indexOf","text","languageSubset","second_best","autoDetection","fixMarkup","p1","highlightBlock","block","originalStream","resultNode","_class","classes","parentNode","blockLanguage","document","createElementNS","innerHTML","textContent","original","highlighted","processed","nodeStack","selectStream","open","attributes","a","close","render","stream","reverse","splice","pop","mergeStreams","prevClassName","currentLang","resultLang","trim","buildClassName","initHighlighting","called","blocks","querySelectorAll","lang","disableAutodetect","configure","user_options","initHighlightingOnLoad","addEventListener","registerLanguage","alias","listLanguages","IDENT_RE","UNDERSCORE_IDENT_RE","NUMBER_RE","C_NUMBER_RE","BINARY_NUMBER_RE","RE_STARTERS_RE","BACKSLASH_ESCAPE","APOS_STRING_MODE","QUOTE_STRING_MODE","PHRASAL_WORDS_MODE","COMMENT","inherits","C_LINE_COMMENT_MODE","C_BLOCK_COMMENT_MODE","HASH_COMMENT_MODE","NUMBER_MODE","C_NUMBER_MODE","BINARY_NUMBER_MODE","CSS_NUMBER_MODE","REGEXP_MODE","TITLE_MODE","UNDERSCORE_TITLE_MODE","METHOD_GUARD","exports","module","KEYWORDS","keyword","literal","built_in","NUMBER","SUBST","TEMPLATE_STRING","PARAMS_CONTAINS","INTERP_IDENT_RE","RULES","VALUE","STRING_MODE","IDENT_MODE","PARENS_MODE","VALUE_WITH_RULESETS","MIXIN_GUARD_MODE","RULE_MODE","AT_RULE_MODE","VAR_RULE_MODE","SELECTOR_MODE","TAG_INTERNALS","root","newline","code","fences","noop","hr","heading","nptable","blockquote","list","html","def","table","lheading","paragraph","Lexer","this","tokens","links","marked","defaults","rules","normal","pedantic","gfm","tables","_label","_title","edit","getRegex","bullet","item","_tag","_comment","merge","lex","src","token","next","loose","cap","bull","b","listStart","listItems","t","space","l","isordered","istask","ischecked","type","rtrim","depth","header","splitCells","align","cells","ordered","start","smartLists","charAt","task","checked","sanitize","pre","sanitizer","href","title","charCodeAt","inline","autolink","url","link","reflink","nolink","strong","em","br","del","InlineLexer","renderer","Renderer","breaks","TextRenderer","Parser","slugger","Slugger","seen","encode","escapeTest","escapeReplace","ch","replacements","escapeTestNoEncode","escapeReplaceNoEncode","unescape","_","n","fromCharCode","parseInt","regex","opt","val","cleanUrl","base","prot","decodeURIComponent","originIndependentUrl","baseUrls","resolveUrl","encodeURI","_punctuation","_escapes","_scheme","_email","_attribute","_href","_extended_email","_backpedal","output","prevCapZero","out","inLink","inRawBlock","lastParenIndex","findClosingBracket","linkLen","outputLink","escapes","codespan","mangle","smartypants","image","Math","random","toString","infostring","escaped","langPrefix","quote","level","raw","headerIds","headerPrefix","slug","xhtml","body","listitem","checkbox","tablerow","content","tablecell","flags","baseUrl","parse","inlineText","tok","peek","parseText","row","cell","j","errMsg","silent","console","log","originalSlug","&","<",">","\"","'","target","tableRow","curr","invert","suffLen","currChar","callback","pending","done","err","setOptions","getDefaults","parser","lexer","inlineLexer"],"mappings":"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","file":"static/js/0.e23b9a39.chunk.js","sourcesContent":["/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n(function (factory) {\n  // Find the global object for export to both the browser and web workers.\n  var globalObject = typeof window === 'object' && window || typeof self === 'object' && self; // Setup highlight.js for different environments. First is Node.js or\n  // CommonJS.\n\n  if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else if (globalObject) {\n    // Export hljs globally even when using AMD for cases when this script\n    // is loaded with others that may still expect a global hljs.\n    globalObject.hljs = factory({}); // Finally register the global hljs with AMD.\n\n    if (typeof define === 'function' && define.amd) {\n      define([], function () {\n        return globalObject.hljs;\n      });\n    }\n  }\n})(function (hljs) {\n  // Convenience variables for build-in objects\n  var ArrayProto = [],\n      objectKeys = Object.keys; // Global internal variables used within the highlight.js library.\n\n  var languages = {},\n      aliases = {}; // Regular expressions used throughout the highlight.js library.\n\n  var noHighlightRe = /^(no-?highlight|plain|text)$/i,\n      languagePrefixRe = /\\blang(?:uage)?-([\\w-]+)\\b/i,\n      fixMarkupRe = /((^(<[^>]+>|\\t|)+|(?:\\n)))/gm; // The object will be assigned by the build tool. It used to synchronize API \n  // of external language files with minified version of the highlight.js library.\n\n  var API_REPLACES;\n  var spanEndTag = '</span>'; // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n\n  var options = {\n    classPrefix: 'hljs-',\n    tabReplace: null,\n    useBR: false,\n    languages: undefined\n  };\n  /* Utility functions */\n\n  function escape(value) {\n    return value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  }\n\n  function tag(node) {\n    return node.nodeName.toLowerCase();\n  }\n\n  function testRe(re, lexeme) {\n    var match = re && re.exec(lexeme);\n    return match && match.index === 0;\n  }\n\n  function isNotHighlighted(language) {\n    return noHighlightRe.test(language);\n  }\n\n  function blockLanguage(block) {\n    var i, match, length, _class;\n\n    var classes = block.className + ' ';\n    classes += block.parentNode ? block.parentNode.className : ''; // language-* takes precedence over non-prefixed class names.\n\n    match = languagePrefixRe.exec(classes);\n\n    if (match) {\n      return getLanguage(match[1]) ? match[1] : 'no-highlight';\n    }\n\n    classes = classes.split(/\\s+/);\n\n    for (i = 0, length = classes.length; i < length; i++) {\n      _class = classes[i];\n\n      if (isNotHighlighted(_class) || getLanguage(_class)) {\n        return _class;\n      }\n    }\n  }\n\n  function inherit(parent) {\n    // inherit(parent, override_obj, override_obj, ...)\n    var key;\n    var result = {};\n    var objects = Array.prototype.slice.call(arguments, 1);\n\n    for (key in parent) {\n      result[key] = parent[key];\n    }\n\n    objects.forEach(function (obj) {\n      for (key in obj) {\n        result[key] = obj[key];\n      }\n    });\n    return result;\n  }\n  /* Stream merging */\n\n\n  function nodeStream(node) {\n    var result = [];\n\n    (function _nodeStream(node, offset) {\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType === 3) offset += child.nodeValue.length;else if (child.nodeType === 1) {\n          result.push({\n            event: 'start',\n            offset: offset,\n            node: child\n          });\n          offset = _nodeStream(child, offset); // Prevent void elements from having an end tag that would actually\n          // double them in the output. There are more void elements in HTML\n          // but we list only those realistically expected in code display.\n\n          if (!tag(child).match(/br|hr|img|input/)) {\n            result.push({\n              event: 'stop',\n              offset: offset,\n              node: child\n            });\n          }\n        }\n      }\n\n      return offset;\n    })(node, 0);\n\n    return result;\n  }\n\n  function mergeStreams(original, highlighted, value) {\n    var processed = 0;\n    var result = '';\n    var nodeStack = [];\n\n    function selectStream() {\n      if (!original.length || !highlighted.length) {\n        return original.length ? original : highlighted;\n      }\n\n      if (original[0].offset !== highlighted[0].offset) {\n        return original[0].offset < highlighted[0].offset ? original : highlighted;\n      }\n      /*\n      To avoid starting the stream just before it should stop the order is\n      ensured that original always starts first and closes last:\n       if (event1 == 'start' && event2 == 'start')\n        return original;\n      if (event1 == 'start' && event2 == 'stop')\n        return highlighted;\n      if (event1 == 'stop' && event2 == 'start')\n        return original;\n      if (event1 == 'stop' && event2 == 'stop')\n        return highlighted;\n       ... which is collapsed to:\n      */\n\n\n      return highlighted[0].event === 'start' ? original : highlighted;\n    }\n\n    function open(node) {\n      function attr_str(a) {\n        return ' ' + a.nodeName + '=\"' + escape(a.value).replace('\"', '&quot;') + '\"';\n      }\n\n      result += '<' + tag(node) + ArrayProto.map.call(node.attributes, attr_str).join('') + '>';\n    }\n\n    function close(node) {\n      result += '</' + tag(node) + '>';\n    }\n\n    function render(event) {\n      (event.event === 'start' ? open : close)(event.node);\n    }\n\n    while (original.length || highlighted.length) {\n      var stream = selectStream();\n      result += escape(value.substring(processed, stream[0].offset));\n      processed = stream[0].offset;\n\n      if (stream === original) {\n        /*\n        On any opening or closing tag of the original markup we first close\n        the entire highlighted node stack, then render the original tag along\n        with all the following original tags at the same offset and then\n        reopen all the tags on the highlighted stack.\n        */\n        nodeStack.reverse().forEach(close);\n\n        do {\n          render(stream.splice(0, 1)[0]);\n          stream = selectStream();\n        } while (stream === original && stream.length && stream[0].offset === processed);\n\n        nodeStack.reverse().forEach(open);\n      } else {\n        if (stream[0].event === 'start') {\n          nodeStack.push(stream[0].node);\n        } else {\n          nodeStack.pop();\n        }\n\n        render(stream.splice(0, 1)[0]);\n      }\n    }\n\n    return result + escape(value.substr(processed));\n  }\n  /* Initialization */\n\n\n  function expand_mode(mode) {\n    if (mode.variants && !mode.cached_variants) {\n      mode.cached_variants = mode.variants.map(function (variant) {\n        return inherit(mode, {\n          variants: null\n        }, variant);\n      });\n    }\n\n    return mode.cached_variants || mode.endsWithParent && [inherit(mode)] || [mode];\n  }\n\n  function restoreLanguageApi(obj) {\n    if (API_REPLACES && !obj.langApiRestored) {\n      obj.langApiRestored = true;\n\n      for (var key in API_REPLACES) {\n        obj[key] && (obj[API_REPLACES[key]] = obj[key]);\n      }\n\n      (obj.contains || []).concat(obj.variants || []).forEach(restoreLanguageApi);\n    }\n  }\n\n  function compileLanguage(language) {\n    function reStr(re) {\n      return re && re.source || re;\n    }\n\n    function langRe(value, global) {\n      return new RegExp(reStr(value), 'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : ''));\n    } // joinRe logically computes regexps.join(separator), but fixes the\n    // backreferences so they continue to match.\n\n\n    function joinRe(regexps, separator) {\n      // backreferenceRe matches an open parenthesis or backreference. To avoid\n      // an incorrect parse, it additionally matches the following:\n      // - [...] elements, where the meaning of parentheses and escapes change\n      // - other escape sequences, so we do not misparse escape sequences as\n      //   interesting elements\n      // - non-matching or lookahead parentheses, which do not capture. These\n      //   follow the '(' with a '?'.\n      var backreferenceRe = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n      var numCaptures = 0;\n      var ret = '';\n\n      for (var i = 0; i < regexps.length; i++) {\n        var offset = numCaptures;\n        var re = reStr(regexps[i]);\n\n        if (i > 0) {\n          ret += separator;\n        }\n\n        while (re.length > 0) {\n          var match = backreferenceRe.exec(re);\n\n          if (match == null) {\n            ret += re;\n            break;\n          }\n\n          ret += re.substring(0, match.index);\n          re = re.substring(match.index + match[0].length);\n\n          if (match[0][0] == '\\\\' && match[1]) {\n            // Adjust the backreference.\n            ret += '\\\\' + String(Number(match[1]) + offset);\n          } else {\n            ret += match[0];\n\n            if (match[0] == '(') {\n              numCaptures++;\n            }\n          }\n        }\n      }\n\n      return ret;\n    }\n\n    function compileMode(mode, parent) {\n      if (mode.compiled) return;\n      mode.compiled = true;\n      mode.keywords = mode.keywords || mode.beginKeywords;\n\n      if (mode.keywords) {\n        var compiled_keywords = {};\n\n        var flatten = function flatten(className, str) {\n          if (language.case_insensitive) {\n            str = str.toLowerCase();\n          }\n\n          str.split(' ').forEach(function (kw) {\n            var pair = kw.split('|');\n            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\n          });\n        };\n\n        if (typeof mode.keywords === 'string') {\n          // string\n          flatten('keyword', mode.keywords);\n        } else {\n          objectKeys(mode.keywords).forEach(function (className) {\n            flatten(className, mode.keywords[className]);\n          });\n        }\n\n        mode.keywords = compiled_keywords;\n      }\n\n      mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true);\n\n      if (parent) {\n        if (mode.beginKeywords) {\n          mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\\\b';\n        }\n\n        if (!mode.begin) mode.begin = /\\B|\\b/;\n        mode.beginRe = langRe(mode.begin);\n        if (mode.endSameAsBegin) mode.end = mode.begin;\n        if (!mode.end && !mode.endsWithParent) mode.end = /\\B|\\b/;\n        if (mode.end) mode.endRe = langRe(mode.end);\n        mode.terminator_end = reStr(mode.end) || '';\n        if (mode.endsWithParent && parent.terminator_end) mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;\n      }\n\n      if (mode.illegal) mode.illegalRe = langRe(mode.illegal);\n      if (mode.relevance == null) mode.relevance = 1;\n\n      if (!mode.contains) {\n        mode.contains = [];\n      }\n\n      mode.contains = Array.prototype.concat.apply([], mode.contains.map(function (c) {\n        return expand_mode(c === 'self' ? mode : c);\n      }));\n      mode.contains.forEach(function (c) {\n        compileMode(c, mode);\n      });\n\n      if (mode.starts) {\n        compileMode(mode.starts, parent);\n      }\n\n      var terminators = mode.contains.map(function (c) {\n        return c.beginKeywords ? '\\\\.?(?:' + c.begin + ')\\\\.?' : c.begin;\n      }).concat([mode.terminator_end, mode.illegal]).map(reStr).filter(Boolean);\n      mode.terminators = terminators.length ? langRe(joinRe(terminators, '|'), true) : {\n        exec: function exec()\n        /*s*/\n        {\n          return null;\n        }\n      };\n    }\n\n    compileMode(language);\n  }\n  /*\n  Core highlighting function. Accepts a language name, or an alias, and a\n  string with the code to highlight. Returns an object with the following\n  properties:\n   - relevance (int)\n  - value (an HTML string with highlighting markup)\n   */\n\n\n  function highlight(name, value, ignore_illegals, continuation) {\n    function escapeRe(value) {\n      return new RegExp(value.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), 'm');\n    }\n\n    function subMode(lexeme, mode) {\n      var i, length;\n\n      for (i = 0, length = mode.contains.length; i < length; i++) {\n        if (testRe(mode.contains[i].beginRe, lexeme)) {\n          if (mode.contains[i].endSameAsBegin) {\n            mode.contains[i].endRe = escapeRe(mode.contains[i].beginRe.exec(lexeme)[0]);\n          }\n\n          return mode.contains[i];\n        }\n      }\n    }\n\n    function endOfMode(mode, lexeme) {\n      if (testRe(mode.endRe, lexeme)) {\n        while (mode.endsParent && mode.parent) {\n          mode = mode.parent;\n        }\n\n        return mode;\n      }\n\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, lexeme);\n      }\n    }\n\n    function isIllegal(lexeme, mode) {\n      return !ignore_illegals && testRe(mode.illegalRe, lexeme);\n    }\n\n    function keywordMatch(mode, match) {\n      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];\n      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];\n    }\n\n    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {\n      var classPrefix = noPrefix ? '' : options.classPrefix,\n          openSpan = '<span class=\"' + classPrefix,\n          closeSpan = leaveOpen ? '' : spanEndTag;\n      openSpan += classname + '\">';\n      return openSpan + insideSpan + closeSpan;\n    }\n\n    function processKeywords() {\n      var keyword_match, last_index, match, result;\n      if (!top.keywords) return escape(mode_buffer);\n      result = '';\n      last_index = 0;\n      top.lexemesRe.lastIndex = 0;\n      match = top.lexemesRe.exec(mode_buffer);\n\n      while (match) {\n        result += escape(mode_buffer.substring(last_index, match.index));\n        keyword_match = keywordMatch(top, match);\n\n        if (keyword_match) {\n          relevance += keyword_match[1];\n          result += buildSpan(keyword_match[0], escape(match[0]));\n        } else {\n          result += escape(match[0]);\n        }\n\n        last_index = top.lexemesRe.lastIndex;\n        match = top.lexemesRe.exec(mode_buffer);\n      }\n\n      return result + escape(mode_buffer.substr(last_index));\n    }\n\n    function processSubLanguage() {\n      var explicit = typeof top.subLanguage === 'string';\n\n      if (explicit && !languages[top.subLanguage]) {\n        return escape(mode_buffer);\n      }\n\n      var result = explicit ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer, top.subLanguage.length ? top.subLanguage : undefined); // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Usecase in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n\n      if (top.relevance > 0) {\n        relevance += result.relevance;\n      }\n\n      if (explicit) {\n        continuations[top.subLanguage] = result.top;\n      }\n\n      return buildSpan(result.language, result.value, false, true);\n    }\n\n    function processBuffer() {\n      result += top.subLanguage != null ? processSubLanguage() : processKeywords();\n      mode_buffer = '';\n    }\n\n    function startNewMode(mode) {\n      result += mode.className ? buildSpan(mode.className, '', true) : '';\n      top = Object.create(mode, {\n        parent: {\n          value: top\n        }\n      });\n    }\n\n    function processLexeme(buffer, lexeme) {\n      mode_buffer += buffer;\n\n      if (lexeme == null) {\n        processBuffer();\n        return 0;\n      }\n\n      var new_mode = subMode(lexeme, top);\n\n      if (new_mode) {\n        if (new_mode.skip) {\n          mode_buffer += lexeme;\n        } else {\n          if (new_mode.excludeBegin) {\n            mode_buffer += lexeme;\n          }\n\n          processBuffer();\n\n          if (!new_mode.returnBegin && !new_mode.excludeBegin) {\n            mode_buffer = lexeme;\n          }\n        }\n\n        startNewMode(new_mode, lexeme);\n        return new_mode.returnBegin ? 0 : lexeme.length;\n      }\n\n      var end_mode = endOfMode(top, lexeme);\n\n      if (end_mode) {\n        var origin = top;\n\n        if (origin.skip) {\n          mode_buffer += lexeme;\n        } else {\n          if (!(origin.returnEnd || origin.excludeEnd)) {\n            mode_buffer += lexeme;\n          }\n\n          processBuffer();\n\n          if (origin.excludeEnd) {\n            mode_buffer = lexeme;\n          }\n        }\n\n        do {\n          if (top.className) {\n            result += spanEndTag;\n          }\n\n          if (!top.skip && !top.subLanguage) {\n            relevance += top.relevance;\n          }\n\n          top = top.parent;\n        } while (top !== end_mode.parent);\n\n        if (end_mode.starts) {\n          if (end_mode.endSameAsBegin) {\n            end_mode.starts.endRe = end_mode.endRe;\n          }\n\n          startNewMode(end_mode.starts, '');\n        }\n\n        return origin.returnEnd ? 0 : lexeme.length;\n      }\n\n      if (isIllegal(lexeme, top)) throw new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || '<unnamed>') + '\"');\n      /*\n      Parser should not reach this point as all types of lexemes should be caught\n      earlier, but if it does due to some bug make sure it advances at least one\n      character forward to prevent infinite looping.\n      */\n\n      mode_buffer += lexeme;\n      return lexeme.length || 1;\n    }\n\n    var language = getLanguage(name);\n\n    if (!language) {\n      throw new Error('Unknown language: \"' + name + '\"');\n    }\n\n    compileLanguage(language);\n    var top = continuation || language;\n    var continuations = {}; // keep continuations for sub-languages\n\n    var result = '',\n        current;\n\n    for (current = top; current !== language; current = current.parent) {\n      if (current.className) {\n        result = buildSpan(current.className, '', true) + result;\n      }\n    }\n\n    var mode_buffer = '';\n    var relevance = 0;\n\n    try {\n      var match,\n          count,\n          index = 0;\n\n      while (true) {\n        top.terminators.lastIndex = index;\n        match = top.terminators.exec(value);\n        if (!match) break;\n        count = processLexeme(value.substring(index, match.index), match[0]);\n        index = match.index + count;\n      }\n\n      processLexeme(value.substr(index));\n\n      for (current = top; current.parent; current = current.parent) {\n        // close dangling modes\n        if (current.className) {\n          result += spanEndTag;\n        }\n      }\n\n      return {\n        relevance: relevance,\n        value: result,\n        language: name,\n        top: top\n      };\n    } catch (e) {\n      if (e.message && e.message.indexOf('Illegal') !== -1) {\n        return {\n          relevance: 0,\n          value: escape(value)\n        };\n      } else {\n        throw e;\n      }\n    }\n  }\n  /*\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n   - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - second_best (object with the same structure for second-best heuristically\n    detected language, may be absent)\n   */\n\n\n  function highlightAuto(text, languageSubset) {\n    languageSubset = languageSubset || options.languages || objectKeys(languages);\n    var result = {\n      relevance: 0,\n      value: escape(text)\n    };\n    var second_best = result;\n    languageSubset.filter(getLanguage).filter(autoDetection).forEach(function (name) {\n      var current = highlight(name, text, false);\n      current.language = name;\n\n      if (current.relevance > second_best.relevance) {\n        second_best = current;\n      }\n\n      if (current.relevance > result.relevance) {\n        second_best = result;\n        result = current;\n      }\n    });\n\n    if (second_best.language) {\n      result.second_best = second_best;\n    }\n\n    return result;\n  }\n  /*\n  Post-processing of the highlighted markup:\n   - replace TABs with something more useful\n  - replace real line-breaks with '<br>' for non-pre containers\n   */\n\n\n  function fixMarkup(value) {\n    return !(options.tabReplace || options.useBR) ? value : value.replace(fixMarkupRe, function (match, p1) {\n      if (options.useBR && match === '\\n') {\n        return '<br>';\n      } else if (options.tabReplace) {\n        return p1.replace(/\\t/g, options.tabReplace);\n      }\n\n      return '';\n    });\n  }\n\n  function buildClassName(prevClassName, currentLang, resultLang) {\n    var language = currentLang ? aliases[currentLang] : resultLang,\n        result = [prevClassName.trim()];\n\n    if (!prevClassName.match(/\\bhljs\\b/)) {\n      result.push('hljs');\n    }\n\n    if (prevClassName.indexOf(language) === -1) {\n      result.push(language);\n    }\n\n    return result.join(' ').trim();\n  }\n  /*\n  Applies highlighting to a DOM node containing code. Accepts a DOM node and\n  two optional parameters for fixMarkup.\n  */\n\n\n  function highlightBlock(block) {\n    var node, originalStream, result, resultNode, text;\n    var language = blockLanguage(block);\n    if (isNotHighlighted(language)) return;\n\n    if (options.useBR) {\n      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n      node.innerHTML = block.innerHTML.replace(/\\n/g, '').replace(/<br[ \\/]*>/g, '\\n');\n    } else {\n      node = block;\n    }\n\n    text = node.textContent;\n    result = language ? highlight(language, text, true) : highlightAuto(text);\n    originalStream = nodeStream(node);\n\n    if (originalStream.length) {\n      resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n      resultNode.innerHTML = result.value;\n      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n    }\n\n    result.value = fixMarkup(result.value);\n    block.innerHTML = result.value;\n    block.className = buildClassName(block.className, language, result.language);\n    block.result = {\n      language: result.language,\n      re: result.relevance\n    };\n\n    if (result.second_best) {\n      block.second_best = {\n        language: result.second_best.language,\n        re: result.second_best.relevance\n      };\n    }\n  }\n  /*\n  Updates highlight.js global options with values passed in the form of an object.\n  */\n\n\n  function configure(user_options) {\n    options = inherit(options, user_options);\n  }\n  /*\n  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.\n  */\n\n\n  function initHighlighting() {\n    if (initHighlighting.called) return;\n    initHighlighting.called = true;\n    var blocks = document.querySelectorAll('pre code');\n    ArrayProto.forEach.call(blocks, highlightBlock);\n  }\n  /*\n  Attaches highlighting to the page load event.\n  */\n\n\n  function initHighlightingOnLoad() {\n    addEventListener('DOMContentLoaded', initHighlighting, false);\n    addEventListener('load', initHighlighting, false);\n  }\n\n  function registerLanguage(name, language) {\n    var lang = languages[name] = language(hljs);\n    restoreLanguageApi(lang);\n\n    if (lang.aliases) {\n      lang.aliases.forEach(function (alias) {\n        aliases[alias] = name;\n      });\n    }\n  }\n\n  function listLanguages() {\n    return objectKeys(languages);\n  }\n\n  function getLanguage(name) {\n    name = (name || '').toLowerCase();\n    return languages[name] || languages[aliases[name]];\n  }\n\n  function autoDetection(name) {\n    var lang = getLanguage(name);\n    return lang && !lang.disableAutodetect;\n  }\n  /* Interface definition */\n\n\n  hljs.highlight = highlight;\n  hljs.highlightAuto = highlightAuto;\n  hljs.fixMarkup = fixMarkup;\n  hljs.highlightBlock = highlightBlock;\n  hljs.configure = configure;\n  hljs.initHighlighting = initHighlighting;\n  hljs.initHighlightingOnLoad = initHighlightingOnLoad;\n  hljs.registerLanguage = registerLanguage;\n  hljs.listLanguages = listLanguages;\n  hljs.getLanguage = getLanguage;\n  hljs.autoDetection = autoDetection;\n  hljs.inherit = inherit; // Common regexps\n\n  hljs.IDENT_RE = '[a-zA-Z]\\\\w*';\n  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\n  hljs.NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\n  hljs.C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\n\n  hljs.BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\n\n  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~'; // Common modes\n\n  hljs.BACKSLASH_ESCAPE = {\n    begin: '\\\\\\\\[\\\\s\\\\S]',\n    relevance: 0\n  };\n  hljs.APOS_STRING_MODE = {\n    className: 'string',\n    begin: '\\'',\n    end: '\\'',\n    illegal: '\\\\n',\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  hljs.QUOTE_STRING_MODE = {\n    className: 'string',\n    begin: '\"',\n    end: '\"',\n    illegal: '\\\\n',\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  hljs.PHRASAL_WORDS_MODE = {\n    begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n  };\n\n  hljs.COMMENT = function (begin, end, inherits) {\n    var mode = hljs.inherit({\n      className: 'comment',\n      begin: begin,\n      end: end,\n      contains: []\n    }, inherits || {});\n    mode.contains.push(hljs.PHRASAL_WORDS_MODE);\n    mode.contains.push({\n      className: 'doctag',\n      begin: '(?:TODO|FIXME|NOTE|BUG|XXX):',\n      relevance: 0\n    });\n    return mode;\n  };\n\n  hljs.C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$');\n  hljs.C_BLOCK_COMMENT_MODE = hljs.COMMENT('/\\\\*', '\\\\*/');\n  hljs.HASH_COMMENT_MODE = hljs.COMMENT('#', '$');\n  hljs.NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.NUMBER_RE,\n    relevance: 0\n  };\n  hljs.C_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.C_NUMBER_RE,\n    relevance: 0\n  };\n  hljs.BINARY_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.BINARY_NUMBER_RE,\n    relevance: 0\n  };\n  hljs.CSS_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.NUMBER_RE + '(' + '%|em|ex|ch|rem' + '|vw|vh|vmin|vmax' + '|cm|mm|in|pt|pc|px' + '|deg|grad|rad|turn' + '|s|ms' + '|Hz|kHz' + '|dpi|dpcm|dppx' + ')?',\n    relevance: 0\n  };\n  hljs.REGEXP_MODE = {\n    className: 'regexp',\n    begin: /\\//,\n    end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [hljs.BACKSLASH_ESCAPE, {\n      begin: /\\[/,\n      end: /\\]/,\n      relevance: 0,\n      contains: [hljs.BACKSLASH_ESCAPE]\n    }]\n  };\n  hljs.TITLE_MODE = {\n    className: 'title',\n    begin: hljs.IDENT_RE,\n    relevance: 0\n  };\n  hljs.UNDERSCORE_TITLE_MODE = {\n    className: 'title',\n    begin: hljs.UNDERSCORE_IDENT_RE,\n    relevance: 0\n  };\n  hljs.METHOD_GUARD = {\n    // excludes method names from keyword processing\n    begin: '\\\\.\\\\s*' + hljs.UNDERSCORE_IDENT_RE,\n    relevance: 0\n  };\n  return hljs;\n});","module.exports = function (hljs) {\n  var IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';\n  var KEYWORDS = {\n    keyword: 'in of if for while finally var new function do return void else break catch ' + 'instanceof with throw case default try this switch continue typeof delete ' + 'let yield const export super debugger as async await static ' + // ECMAScript 6 modules import\n    'import from as',\n    literal: 'true false null undefined NaN Infinity',\n    built_in: 'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' + 'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' + 'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' + 'TypeError URIError Number Math Date String RegExp Array Float32Array ' + 'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' + 'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' + 'module console window document Symbol Set Map WeakSet WeakMap Proxy Reflect ' + 'Promise'\n  };\n  var NUMBER = {\n    className: 'number',\n    variants: [{\n      begin: '\\\\b(0[bB][01]+)'\n    }, {\n      begin: '\\\\b(0[oO][0-7]+)'\n    }, {\n      begin: hljs.C_NUMBER_RE\n    }],\n    relevance: 0\n  };\n  var SUBST = {\n    className: 'subst',\n    begin: '\\\\$\\\\{',\n    end: '\\\\}',\n    keywords: KEYWORDS,\n    contains: [] // defined later\n\n  };\n  var TEMPLATE_STRING = {\n    className: 'string',\n    begin: '`',\n    end: '`',\n    contains: [hljs.BACKSLASH_ESCAPE, SUBST]\n  };\n  SUBST.contains = [hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, NUMBER, hljs.REGEXP_MODE];\n  var PARAMS_CONTAINS = SUBST.contains.concat([hljs.C_BLOCK_COMMENT_MODE, hljs.C_LINE_COMMENT_MODE]);\n  return {\n    aliases: ['js', 'jsx'],\n    keywords: KEYWORDS,\n    contains: [{\n      className: 'meta',\n      relevance: 10,\n      begin: /^\\s*['\"]use (strict|asm)['\"]/\n    }, {\n      className: 'meta',\n      begin: /^#!/,\n      end: /$/\n    }, hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE, TEMPLATE_STRING, hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, NUMBER, {\n      // object attr container\n      begin: /[{,]\\s*/,\n      relevance: 0,\n      contains: [{\n        begin: IDENT_RE + '\\\\s*:',\n        returnBegin: true,\n        relevance: 0,\n        contains: [{\n          className: 'attr',\n          begin: IDENT_RE,\n          relevance: 0\n        }]\n      }]\n    }, {\n      // \"value\" container\n      begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n      keywords: 'return throw case',\n      contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, hljs.REGEXP_MODE, {\n        className: 'function',\n        begin: '(\\\\(.*?\\\\)|' + IDENT_RE + ')\\\\s*=>',\n        returnBegin: true,\n        end: '\\\\s*=>',\n        contains: [{\n          className: 'params',\n          variants: [{\n            begin: IDENT_RE\n          }, {\n            begin: /\\(\\s*\\)/\n          }, {\n            begin: /\\(/,\n            end: /\\)/,\n            excludeBegin: true,\n            excludeEnd: true,\n            keywords: KEYWORDS,\n            contains: PARAMS_CONTAINS\n          }]\n        }]\n      }, {\n        // E4X / JSX\n        begin: /</,\n        end: /(\\/\\w+|\\w+\\/)>/,\n        subLanguage: 'xml',\n        contains: [{\n          begin: /<\\w+\\s*\\/>/,\n          skip: true\n        }, {\n          begin: /<\\w+/,\n          end: /(\\/\\w+|\\w+\\/)>/,\n          skip: true,\n          contains: [{\n            begin: /<\\w+\\s*\\/>/,\n            skip: true\n          }, 'self']\n        }]\n      }],\n      relevance: 0\n    }, {\n      className: 'function',\n      beginKeywords: 'function',\n      end: /\\{/,\n      excludeEnd: true,\n      contains: [hljs.inherit(hljs.TITLE_MODE, {\n        begin: IDENT_RE\n      }), {\n        className: 'params',\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        contains: PARAMS_CONTAINS\n      }],\n      illegal: /\\[|%/\n    }, {\n      begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n\n    }, hljs.METHOD_GUARD, {\n      // ES6 class\n      className: 'class',\n      beginKeywords: 'class',\n      end: /[{;=]/,\n      excludeEnd: true,\n      illegal: /[:\"\\[\\]]/,\n      contains: [{\n        beginKeywords: 'extends'\n      }, hljs.UNDERSCORE_TITLE_MODE]\n    }, {\n      beginKeywords: 'constructor get set',\n      end: /\\{/,\n      excludeEnd: true\n    }],\n    illegal: /#(?!!)/\n  };\n};","module.exports = function (hljs) {\n  var IDENT_RE = '[\\\\w-]+'; // yes, Less identifiers may begin with a digit\n\n  var INTERP_IDENT_RE = '(' + IDENT_RE + '|@{' + IDENT_RE + '})';\n  /* Generic Modes */\n\n  var RULES = [],\n      VALUE = []; // forward def. for recursive modes\n\n  var STRING_MODE = function STRING_MODE(c) {\n    return {\n      // Less strings are not multiline (also include '~' for more consistent coloring of \"escaped\" strings)\n      className: 'string',\n      begin: '~?' + c + '.*?' + c\n    };\n  };\n\n  var IDENT_MODE = function IDENT_MODE(name, begin, relevance) {\n    return {\n      className: name,\n      begin: begin,\n      relevance: relevance\n    };\n  };\n\n  var PARENS_MODE = {\n    // used only to properly balance nested parens inside mixin call, def. arg list\n    begin: '\\\\(',\n    end: '\\\\)',\n    contains: VALUE,\n    relevance: 0\n  }; // generic Less highlighter (used almost everywhere except selectors):\n\n  VALUE.push(hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, STRING_MODE(\"'\"), STRING_MODE('\"'), hljs.CSS_NUMBER_MODE, // fixme: it does not include dot for numbers like .5em :(\n  {\n    begin: '(url|data-uri)\\\\(',\n    starts: {\n      className: 'string',\n      end: '[\\\\)\\\\n]',\n      excludeEnd: true\n    }\n  }, IDENT_MODE('number', '#[0-9A-Fa-f]+\\\\b'), PARENS_MODE, IDENT_MODE('variable', '@@?' + IDENT_RE, 10), IDENT_MODE('variable', '@{' + IDENT_RE + '}'), IDENT_MODE('built_in', '~?`[^`]*?`'), // inline javascript (or whatever host language) *multiline* string\n  {\n    // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):\n    className: 'attribute',\n    begin: IDENT_RE + '\\\\s*:',\n    end: ':',\n    returnBegin: true,\n    excludeEnd: true\n  }, {\n    className: 'meta',\n    begin: '!important'\n  });\n  var VALUE_WITH_RULESETS = VALUE.concat({\n    begin: '{',\n    end: '}',\n    contains: RULES\n  });\n  var MIXIN_GUARD_MODE = {\n    beginKeywords: 'when',\n    endsWithParent: true,\n    contains: [{\n      beginKeywords: 'and not'\n    }].concat(VALUE) // using this form to override VALUE’s 'function' match\n\n  };\n  /* Rule-Level Modes */\n\n  var RULE_MODE = {\n    begin: INTERP_IDENT_RE + '\\\\s*:',\n    returnBegin: true,\n    end: '[;}]',\n    relevance: 0,\n    contains: [{\n      className: 'attribute',\n      begin: INTERP_IDENT_RE,\n      end: ':',\n      excludeEnd: true,\n      starts: {\n        endsWithParent: true,\n        illegal: '[<=$]',\n        relevance: 0,\n        contains: VALUE\n      }\n    }]\n  };\n  var AT_RULE_MODE = {\n    className: 'keyword',\n    begin: '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\\\b',\n    starts: {\n      end: '[;{}]',\n      returnEnd: true,\n      contains: VALUE,\n      relevance: 0\n    }\n  }; // variable definitions and calls\n\n  var VAR_RULE_MODE = {\n    className: 'variable',\n    variants: [// using more strict pattern for higher relevance to increase chances of Less detection.\n    // this is *the only* Less specific statement used in most of the sources, so...\n    // (we’ll still often loose to the css-parser unless there's '//' comment,\n    // simply because 1 variable just can't beat 99 properties :)\n    {\n      begin: '@' + IDENT_RE + '\\\\s*:',\n      relevance: 15\n    }, {\n      begin: '@' + IDENT_RE\n    }],\n    starts: {\n      end: '[;}]',\n      returnEnd: true,\n      contains: VALUE_WITH_RULESETS\n    }\n  };\n  var SELECTOR_MODE = {\n    // first parse unambiguous selectors (i.e. those not starting with tag)\n    // then fall into the scary lookahead-discriminator variant.\n    // this mode also handles mixin definitions and calls\n    variants: [{\n      begin: '[\\\\.#:&\\\\[>]',\n      end: '[;{}]' // mixin calls end with ';'\n\n    }, {\n      begin: INTERP_IDENT_RE,\n      end: '{'\n    }],\n    returnBegin: true,\n    returnEnd: true,\n    illegal: '[<=\\'$\"]',\n    relevance: 0,\n    contains: [hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, MIXIN_GUARD_MODE, IDENT_MODE('keyword', 'all\\\\b'), IDENT_MODE('variable', '@{' + IDENT_RE + '}'), // otherwise it’s identified as tag\n    IDENT_MODE('selector-tag', INTERP_IDENT_RE + '%?', 0), // '%' for more consistent coloring of @keyframes \"tags\"\n    IDENT_MODE('selector-id', '#' + INTERP_IDENT_RE), IDENT_MODE('selector-class', '\\\\.' + INTERP_IDENT_RE, 0), IDENT_MODE('selector-tag', '&', 0), {\n      className: 'selector-attr',\n      begin: '\\\\[',\n      end: '\\\\]'\n    }, {\n      className: 'selector-pseudo',\n      begin: /:(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\"'.]+/\n    }, {\n      begin: '\\\\(',\n      end: '\\\\)',\n      contains: VALUE_WITH_RULESETS\n    }, // argument list of parametric mixins\n    {\n      begin: '!important' // eat !important after mixin call or it will be colored as tag\n\n    }]\n  };\n  RULES.push(hljs.C_LINE_COMMENT_MODE, hljs.C_BLOCK_COMMENT_MODE, AT_RULE_MODE, VAR_RULE_MODE, RULE_MODE, SELECTOR_MODE);\n  return {\n    case_insensitive: true,\n    illegal: '[=>\\'/<($\"]',\n    contains: RULES\n  };\n};","module.exports = function (hljs) {\n  var XML_IDENT_RE = '[A-Za-z0-9\\\\._:-]+';\n  var TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [{\n      className: 'attr',\n      begin: XML_IDENT_RE,\n      relevance: 0\n    }, {\n      begin: /=\\s*/,\n      relevance: 0,\n      contains: [{\n        className: 'string',\n        endsParent: true,\n        variants: [{\n          begin: /\"/,\n          end: /\"/\n        }, {\n          begin: /'/,\n          end: /'/\n        }, {\n          begin: /[^\\s\"'=<>`]+/\n        }]\n      }]\n    }]\n  };\n  return {\n    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist'],\n    case_insensitive: true,\n    contains: [{\n      className: 'meta',\n      begin: '<!DOCTYPE',\n      end: '>',\n      relevance: 10,\n      contains: [{\n        begin: '\\\\[',\n        end: '\\\\]'\n      }]\n    }, hljs.COMMENT('<!--', '-->', {\n      relevance: 10\n    }), {\n      begin: '<\\\\!\\\\[CDATA\\\\[',\n      end: '\\\\]\\\\]>',\n      relevance: 10\n    }, {\n      className: 'meta',\n      begin: /<\\?xml/,\n      end: /\\?>/,\n      relevance: 10\n    }, {\n      begin: /<\\?(php)?/,\n      end: /\\?>/,\n      subLanguage: 'php',\n      contains: [// We don't want the php closing tag ?> to close the PHP block when\n      // inside any of the following blocks:\n      {\n        begin: '/\\\\*',\n        end: '\\\\*/',\n        skip: true\n      }, {\n        begin: 'b\"',\n        end: '\"',\n        skip: true\n      }, {\n        begin: 'b\\'',\n        end: '\\'',\n        skip: true\n      }, hljs.inherit(hljs.APOS_STRING_MODE, {\n        illegal: null,\n        className: null,\n        contains: null,\n        skip: true\n      }), hljs.inherit(hljs.QUOTE_STRING_MODE, {\n        illegal: null,\n        className: null,\n        contains: null,\n        skip: true\n      })]\n    }, {\n      className: 'tag',\n\n      /*\n      The lookahead pattern (?=...) ensures that 'begin' only matches\n      '<style' as a single word, followed by a whitespace or an\n      ending braket. The '$' is needed for the lexeme to be recognized\n      by hljs.subMode() that tests lexemes outside the stream.\n      */\n      begin: '<style(?=\\\\s|>|$)',\n      end: '>',\n      keywords: {\n        name: 'style'\n      },\n      contains: [TAG_INTERNALS],\n      starts: {\n        end: '</style>',\n        returnEnd: true,\n        subLanguage: ['css', 'xml']\n      }\n    }, {\n      className: 'tag',\n      // See the comment in the <style tag about the lookahead pattern\n      begin: '<script(?=\\\\s|>|$)',\n      end: '>',\n      keywords: {\n        name: 'script'\n      },\n      contains: [TAG_INTERNALS],\n      starts: {\n        end: '\\<\\/script\\>',\n        returnEnd: true,\n        subLanguage: ['actionscript', 'javascript', 'handlebars', 'xml']\n      }\n    }, {\n      className: 'tag',\n      begin: '</?',\n      end: '/?>',\n      contains: [{\n        className: 'name',\n        begin: /[^\\/><\\s]+/,\n        relevance: 0\n      }, TAG_INTERNALS]\n    }]\n  };\n};","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n;\n\n(function (root) {\n  'use strict';\n  /**\n   * Block-Level Grammar\n   */\n\n  var block = {\n    newline: /^\\n+/,\n    code: /^( {4}[^\\n]+\\n*)+/,\n    fences: noop,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n    nptable: noop,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?\\\\?>\\\\n*' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?>\\\\n*' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\\\\n*' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noop,\n    lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n    paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading| {0,3}>|<\\/?(?:tag)(?: +|\\n|\\/?>)|<(?:script|pre|style|!--))[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block.def = edit(block.def).replace('label', block._label).replace('title', block._title).getRegex();\n  block.bullet = /(?:[*+-]|\\d{1,9}\\.)/;\n  block.item = /^( *)(bull) ?[^\\n]*(?:\\n(?!\\1bull ?)[^\\n]*)*/;\n  block.item = edit(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();\n  block.list = edit(block.list).replace(/bull/g, block.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block.def.source + ')').getRegex();\n  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block._comment = /<!--(?!-?>)[\\s\\S]*?-->/;\n  block.html = edit(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block.paragraph = edit(block.paragraph).replace('hr', block.hr).replace('heading', block.heading).replace('lheading', block.lheading).replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block.blockquote = edit(block.blockquote).replace('paragraph', block.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block.normal = merge({}, block);\n  /**\n   * GFM Block Grammar\n   */\n\n  block.gfm = merge({}, block.normal, {\n    fences: /^ {0,3}(`{3,}|~{3,})([^`\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n    paragraph: /^/,\n    heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n  });\n  block.gfm.paragraph = edit(block.paragraph).replace('(?!', '(?!' + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|' + block.list.source.replace('\\\\1', '\\\\3') + '|').getRegex();\n  /**\n   * GFM + Tables Block Grammar\n   */\n\n  block.tables = merge({}, block.gfm, {\n    nptable: /^ *([^|\\n ].*\\|.*)\\n *([-:]+ *\\|[-| :]*)(?:\\n((?:.*[^>\\n ].*(?:\\n|$))*)\\n*|$)/,\n    table: /^ *\\|(.+)\\n *\\|?( *[-:]+[-| :]*)(?:\\n((?: *[^>\\n ].*(?:\\n|$))*)\\n*|$)/\n  });\n  /**\n   * Pedantic grammar\n   */\n\n  block.pedantic = merge({}, block.normal, {\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/\n  });\n  /**\n   * Block Lexer\n   */\n\n  function Lexer(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || marked.defaults;\n    this.rules = block.normal;\n\n    if (this.options.pedantic) {\n      this.rules = block.pedantic;\n    } else if (this.options.gfm) {\n      if (this.options.tables) {\n        this.rules = block.tables;\n      } else {\n        this.rules = block.gfm;\n      }\n    }\n  }\n  /**\n   * Expose Block Rules\n   */\n\n\n  Lexer.rules = block;\n  /**\n   * Static Lex Method\n   */\n\n  Lexer.lex = function (src, options) {\n    var lexer = new Lexer(options);\n    return lexer.lex(src);\n  };\n  /**\n   * Preprocessing\n   */\n\n\n  Lexer.prototype.lex = function (src) {\n    src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ').replace(/\\u00a0/g, ' ').replace(/\\u2424/g, '\\n');\n    return this.token(src, true);\n  };\n  /**\n   * Lexing\n   */\n\n\n  Lexer.prototype.token = function (src, top) {\n    src = src.replace(/^ +$/gm, '');\n    var next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;\n\n    while (src) {\n      // newline\n      if (cap = this.rules.newline.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        if (cap[0].length > 1) {\n          this.tokens.push({\n            type: 'space'\n          });\n        }\n      } // code\n\n\n      if (cap = this.rules.code.exec(src)) {\n        src = src.substring(cap[0].length);\n        cap = cap[0].replace(/^ {4}/gm, '');\n        this.tokens.push({\n          type: 'code',\n          text: !this.options.pedantic ? rtrim(cap, '\\n') : cap\n        });\n        continue;\n      } // fences (gfm)\n\n\n      if (cap = this.rules.fences.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'code',\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: cap[3] || ''\n        });\n        continue;\n      } // heading\n\n\n      if (cap = this.rules.heading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[1].length,\n          text: cap[2]\n        });\n        continue;\n      } // table no leading pipe (gfm)\n\n\n      if (cap = this.rules.nptable.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i], item.header.length);\n          }\n\n          this.tokens.push(item);\n          continue;\n        }\n      } // hr\n\n\n      if (cap = this.rules.hr.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'hr'\n        });\n        continue;\n      } // blockquote\n\n\n      if (cap = this.rules.blockquote.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'blockquote_start'\n        });\n        cap = cap[0].replace(/^ *> ?/gm, ''); // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n\n        this.token(cap, top);\n        this.tokens.push({\n          type: 'blockquote_end'\n        });\n        continue;\n      } // list\n\n\n      if (cap = this.rules.list.exec(src)) {\n        src = src.substring(cap[0].length);\n        bull = cap[2];\n        isordered = bull.length > 1;\n        listStart = {\n          type: 'list_start',\n          ordered: isordered,\n          start: isordered ? +bull : '',\n          loose: false\n        };\n        this.tokens.push(listStart); // Get each top-level item.\n\n        cap = cap[0].match(this.rules.item);\n        listItems = [];\n        next = false;\n        l = cap.length;\n        i = 0;\n\n        for (; i < l; i++) {\n          item = cap[i]; // Remove the list item's bullet\n          // so it is seen as the next token.\n\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) */, ''); // Outdent whatever the\n          // list item contains. Hacky.\n\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n          } // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n\n\n          if (i !== l - 1) {\n            b = block.bullet.exec(cap[i + 1])[0];\n\n            if (bull.length > 1 ? b.length === 1 : b.length > 1 || this.options.smartLists && b !== bull) {\n              src = cap.slice(i + 1).join('\\n') + src;\n              i = l - 1;\n            }\n          } // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n\n\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            listStart.loose = true;\n          } // Check for task list items\n\n\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          t = {\n            type: 'list_item_start',\n            task: istask,\n            checked: ischecked,\n            loose: loose\n          };\n          listItems.push(t);\n          this.tokens.push(t); // Recurse.\n\n          this.token(item, false);\n          this.tokens.push({\n            type: 'list_item_end'\n          });\n        }\n\n        if (listStart.loose) {\n          l = listItems.length;\n          i = 0;\n\n          for (; i < l; i++) {\n            listItems[i].loose = true;\n          }\n        }\n\n        this.tokens.push({\n          type: 'list_end'\n        });\n        continue;\n      } // html\n\n\n      if (cap = this.rules.html.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: this.options.sanitize ? 'paragraph' : 'html',\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: cap[0]\n        });\n        continue;\n      } // def\n\n\n      if (top && (cap = this.rules.def.exec(src))) {\n        src = src.substring(cap[0].length);\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          };\n        }\n\n        continue;\n      } // table (gfm)\n\n\n      if (cap = this.rules.table.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n          }\n\n          this.tokens.push(item);\n          continue;\n        }\n      } // lheading\n\n\n      if (cap = this.rules.lheading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[2] === '=' ? 1 : 2,\n          text: cap[1]\n        });\n        continue;\n      } // top-level paragraph\n\n\n      if (top && (cap = this.rules.paragraph.exec(src))) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'paragraph',\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n        });\n        continue;\n      } // text\n\n\n      if (cap = this.rules.text.exec(src)) {\n        // Top-level should never reach here.\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'text',\n          text: cap[0]\n        });\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return this.tokens;\n  };\n  /**\n   * Inline-Level Grammar\n   */\n\n\n  var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noop,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(href(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    strong: /^__([^\\s_])__(?!_)|^\\*\\*([^\\s*])\\*\\*(?!\\*)|^__([^\\s][\\s\\S]*?[^\\s])__(?!_)|^\\*\\*([^\\s][\\s\\S]*?[^\\s])\\*\\*(?!\\*)/,\n    em: /^_([^\\s_])_(?!_)|^\\*([^\\s*\"<\\[])\\*(?!\\*)|^_([^\\s][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s\"<\\[][\\s\\S]*?[^\\s*])\\*(?!\\*)|^\\*([^\\s*\"<\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noop,\n    text: /^(`+|[^`])(?:[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n))|(?= {2,}\\n))/\n  }; // list of punctuation marks from common mark spec\n  // without ` and ] to workaround Rule 17 (inline code blocks/links)\n\n  inline._punctuation = '!\"#$%&\\'()*+,\\\\-./:;<=>?@\\\\[^_{|}~';\n  inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline.autolink = edit(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();\n  inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline.tag = edit(inline.tag).replace('comment', block._comment).replace('attribute', inline._attribute).getRegex();\n  inline._label = /(?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]?|`[^`]*`|`(?!`)|[^\\[\\]\\\\`])*?/;\n  inline._href = /\\s*(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*)/;\n  inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline.link = edit(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();\n  inline.reflink = edit(inline.reflink).replace('label', inline._label).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline.normal = merge({}, inline);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline.pedantic = merge({}, inline.normal, {\n    strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n    em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline.gfm = merge({}, inline.normal, {\n    escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n    text: /^(`+|[^`])(?:[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?= {2,}\\n|[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n  });\n  inline.gfm.url = edit(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline.breaks = merge({}, inline.gfm, {\n    br: edit(inline.br).replace('{2,}', '*').getRegex(),\n    text: edit(inline.gfm.text).replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  /**\n   * Inline Lexer & Compiler\n   */\n\n  function InlineLexer(links, options) {\n    this.options = options || marked.defaults;\n    this.links = links;\n    this.rules = inline.normal;\n    this.renderer = this.options.renderer || new Renderer();\n    this.renderer.options = this.options;\n\n    if (!this.links) {\n      throw new Error('Tokens array requires a `links` property.');\n    }\n\n    if (this.options.pedantic) {\n      this.rules = inline.pedantic;\n    } else if (this.options.gfm) {\n      if (this.options.breaks) {\n        this.rules = inline.breaks;\n      } else {\n        this.rules = inline.gfm;\n      }\n    }\n  }\n  /**\n   * Expose Inline Rules\n   */\n\n\n  InlineLexer.rules = inline;\n  /**\n   * Static Lexing/Compiling Method\n   */\n\n  InlineLexer.output = function (src, links, options) {\n    var inline = new InlineLexer(links, options);\n    return inline.output(src);\n  };\n  /**\n   * Lexing/Compiling\n   */\n\n\n  InlineLexer.prototype.output = function (src) {\n    var out = '',\n        link,\n        text,\n        href,\n        title,\n        cap,\n        prevCapZero;\n\n    while (src) {\n      // escape\n      if (cap = this.rules.escape.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += escape(cap[1]);\n        continue;\n      } // tag\n\n\n      if (cap = this.rules.tag.exec(src)) {\n        if (!this.inLink && /^<a /i.test(cap[0])) {\n          this.inLink = true;\n        } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.inLink = false;\n        }\n\n        if (!this.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.inRawBlock = true;\n        } else if (this.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.inRawBlock = false;\n        }\n\n        src = src.substring(cap[0].length);\n        out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];\n        continue;\n      } // link\n\n\n      if (cap = this.rules.link.exec(src)) {\n        var lastParenIndex = findClosingBracket(cap[2], '()');\n\n        if (lastParenIndex > -1) {\n          var linkLen = cap[0].length - (cap[2].length - lastParenIndex) - (cap[3] || '').length;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n\n        src = src.substring(cap[0].length);\n        this.inLink = true;\n        href = cap[2];\n\n        if (this.options.pedantic) {\n          link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          } else {\n            title = '';\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n        out += this.outputLink(cap, {\n          href: InlineLexer.escapes(href),\n          title: InlineLexer.escapes(title)\n        });\n        this.inLink = false;\n        continue;\n      } // reflink, nolink\n\n\n      if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {\n        src = src.substring(cap[0].length);\n        link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = this.links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          out += cap[0].charAt(0);\n          src = cap[0].substring(1) + src;\n          continue;\n        }\n\n        this.inLink = true;\n        out += this.outputLink(cap, link);\n        this.inLink = false;\n        continue;\n      } // strong\n\n\n      if (cap = this.rules.strong.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));\n        continue;\n      } // em\n\n\n      if (cap = this.rules.em.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));\n        continue;\n      } // code\n\n\n      if (cap = this.rules.code.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.codespan(escape(cap[2].trim(), true));\n        continue;\n      } // br\n\n\n      if (cap = this.rules.br.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.br();\n        continue;\n      } // del (gfm)\n\n\n      if (cap = this.rules.del.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.del(this.output(cap[1]));\n        continue;\n      } // autolink\n\n\n      if (cap = this.rules.autolink.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        if (cap[2] === '@') {\n          text = escape(this.mangle(cap[1]));\n          href = 'mailto:' + text;\n        } else {\n          text = escape(cap[1]);\n          href = text;\n        }\n\n        out += this.renderer.link(href, null, text);\n        continue;\n      } // url (gfm)\n\n\n      if (!this.inLink && (cap = this.rules.url.exec(src))) {\n        if (cap[2] === '@') {\n          text = escape(cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        src = src.substring(cap[0].length);\n        out += this.renderer.link(href, null, text);\n        continue;\n      } // text\n\n\n      if (cap = this.rules.text.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        if (this.inRawBlock) {\n          out += this.renderer.text(cap[0]);\n        } else {\n          out += this.renderer.text(escape(this.smartypants(cap[0])));\n        }\n\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return out;\n  };\n\n  InlineLexer.escapes = function (text) {\n    return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;\n  };\n  /**\n   * Compile Link\n   */\n\n\n  InlineLexer.prototype.outputLink = function (cap, link) {\n    var href = link.href,\n        title = link.title ? escape(link.title) : null;\n    return cap[0].charAt(0) !== '!' ? this.renderer.link(href, title, this.output(cap[1])) : this.renderer.image(href, title, escape(cap[1]));\n  };\n  /**\n   * Smartypants Transformations\n   */\n\n\n  InlineLexer.prototype.smartypants = function (text) {\n    if (!this.options.smartypants) return text;\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  };\n  /**\n   * Mangle Links\n   */\n\n\n  InlineLexer.prototype.mangle = function (text) {\n    if (!this.options.mangle) return text;\n    var out = '',\n        l = text.length,\n        i = 0,\n        ch;\n\n    for (; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  };\n  /**\n   * Renderer\n   */\n\n\n  function Renderer(options) {\n    this.options = options || marked.defaults;\n  }\n\n  Renderer.prototype.code = function (code, infostring, escaped) {\n    var lang = (infostring || '').match(/\\S*/)[0];\n\n    if (this.options.highlight) {\n      var out = this.options.highlight(code, lang);\n\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    if (!lang) {\n      return '<pre><code>' + (escaped ? code : escape(code, true)) + '</code></pre>';\n    }\n\n    return '<pre><code class=\"' + this.options.langPrefix + escape(lang, true) + '\">' + (escaped ? code : escape(code, true)) + '</code></pre>\\n';\n  };\n\n  Renderer.prototype.blockquote = function (quote) {\n    return '<blockquote>\\n' + quote + '</blockquote>\\n';\n  };\n\n  Renderer.prototype.html = function (html) {\n    return html;\n  };\n\n  Renderer.prototype.heading = function (text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n    } // ignore IDs\n\n\n    return '<h' + level + '>' + text + '</h' + level + '>\\n';\n  };\n\n  Renderer.prototype.hr = function () {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  };\n\n  Renderer.prototype.list = function (body, ordered, start) {\n    var type = ordered ? 'ol' : 'ul',\n        startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  };\n\n  Renderer.prototype.listitem = function (text) {\n    return '<li>' + text + '</li>\\n';\n  };\n\n  Renderer.prototype.checkbox = function (checked) {\n    return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n  };\n\n  Renderer.prototype.paragraph = function (text) {\n    return '<p>' + text + '</p>\\n';\n  };\n\n  Renderer.prototype.table = function (header, body) {\n    if (body) body = '<tbody>' + body + '</tbody>';\n    return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n  };\n\n  Renderer.prototype.tablerow = function (content) {\n    return '<tr>\\n' + content + '</tr>\\n';\n  };\n\n  Renderer.prototype.tablecell = function (content, flags) {\n    var type = flags.header ? 'th' : 'td';\n    var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n    return tag + content + '</' + type + '>\\n';\n  }; // span level renderer\n\n\n  Renderer.prototype.strong = function (text) {\n    return '<strong>' + text + '</strong>';\n  };\n\n  Renderer.prototype.em = function (text) {\n    return '<em>' + text + '</em>';\n  };\n\n  Renderer.prototype.codespan = function (text) {\n    return '<code>' + text + '</code>';\n  };\n\n  Renderer.prototype.br = function () {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  };\n\n  Renderer.prototype.del = function (text) {\n    return '<del>' + text + '</del>';\n  };\n\n  Renderer.prototype.link = function (href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n    if (href === null) {\n      return text;\n    }\n\n    var out = '<a href=\"' + escape(href) + '\"';\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += '>' + text + '</a>';\n    return out;\n  };\n\n  Renderer.prototype.image = function (href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n    if (href === null) {\n      return text;\n    }\n\n    var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  };\n\n  Renderer.prototype.text = function (text) {\n    return text;\n  };\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n\n\n  function TextRenderer() {} // no need for block level renderers\n\n\n  TextRenderer.prototype.strong = TextRenderer.prototype.em = TextRenderer.prototype.codespan = TextRenderer.prototype.del = TextRenderer.prototype.text = function (text) {\n    return text;\n  };\n\n  TextRenderer.prototype.link = TextRenderer.prototype.image = function (href, title, text) {\n    return '' + text;\n  };\n\n  TextRenderer.prototype.br = function () {\n    return '';\n  };\n  /**\n   * Parsing & Compiling\n   */\n\n\n  function Parser(options) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || marked.defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.slugger = new Slugger();\n  }\n  /**\n   * Static Parse Method\n   */\n\n\n  Parser.parse = function (src, options) {\n    var parser = new Parser(options);\n    return parser.parse(src);\n  };\n  /**\n   * Parse Loop\n   */\n\n\n  Parser.prototype.parse = function (src) {\n    this.inline = new InlineLexer(src.links, this.options); // use an InlineLexer with a TextRenderer to extract pure text\n\n    this.inlineText = new InlineLexer(src.links, merge({}, this.options, {\n      renderer: new TextRenderer()\n    }));\n    this.tokens = src.reverse();\n    var out = '';\n\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  };\n  /**\n   * Next Token\n   */\n\n\n  Parser.prototype.next = function () {\n    return this.token = this.tokens.pop();\n  };\n  /**\n   * Preview Next Token\n   */\n\n\n  Parser.prototype.peek = function () {\n    return this.tokens[this.tokens.length - 1] || 0;\n  };\n  /**\n   * Parse Text Tokens\n   */\n\n\n  Parser.prototype.parseText = function () {\n    var body = this.token.text;\n\n    while (this.peek().type === 'text') {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inline.output(body);\n  };\n  /**\n   * Parse Current Token\n   */\n\n\n  Parser.prototype.tok = function () {\n    switch (this.token.type) {\n      case 'space':\n        {\n          return '';\n        }\n\n      case 'hr':\n        {\n          return this.renderer.hr();\n        }\n\n      case 'heading':\n        {\n          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)), this.slugger);\n        }\n\n      case 'code':\n        {\n          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);\n        }\n\n      case 'table':\n        {\n          var header = '',\n              body = '',\n              i,\n              row,\n              cell,\n              j; // header\n\n          cell = '';\n\n          for (i = 0; i < this.token.header.length; i++) {\n            cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {\n              header: true,\n              align: this.token.align[i]\n            });\n          }\n\n          header += this.renderer.tablerow(cell);\n\n          for (i = 0; i < this.token.cells.length; i++) {\n            row = this.token.cells[i];\n            cell = '';\n\n            for (j = 0; j < row.length; j++) {\n              cell += this.renderer.tablecell(this.inline.output(row[j]), {\n                header: false,\n                align: this.token.align[j]\n              });\n            }\n\n            body += this.renderer.tablerow(cell);\n          }\n\n          return this.renderer.table(header, body);\n        }\n\n      case 'blockquote_start':\n        {\n          body = '';\n\n          while (this.next().type !== 'blockquote_end') {\n            body += this.tok();\n          }\n\n          return this.renderer.blockquote(body);\n        }\n\n      case 'list_start':\n        {\n          body = '';\n          var ordered = this.token.ordered,\n              start = this.token.start;\n\n          while (this.next().type !== 'list_end') {\n            body += this.tok();\n          }\n\n          return this.renderer.list(body, ordered, start);\n        }\n\n      case 'list_item_start':\n        {\n          body = '';\n          var loose = this.token.loose;\n          var checked = this.token.checked;\n          var task = this.token.task;\n\n          if (this.token.task) {\n            body += this.renderer.checkbox(checked);\n          }\n\n          while (this.next().type !== 'list_item_end') {\n            body += !loose && this.token.type === 'text' ? this.parseText() : this.tok();\n          }\n\n          return this.renderer.listitem(body, task, checked);\n        }\n\n      case 'html':\n        {\n          // TODO parse inline content if parameter markdown=1\n          return this.renderer.html(this.token.text);\n        }\n\n      case 'paragraph':\n        {\n          return this.renderer.paragraph(this.inline.output(this.token.text));\n        }\n\n      case 'text':\n        {\n          return this.renderer.paragraph(this.parseText());\n        }\n\n      default:\n        {\n          var errMsg = 'Token with \"' + this.token.type + '\" type was not found.';\n\n          if (this.options.silent) {\n            console.log(errMsg);\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n    }\n  };\n  /**\n   * Slugger generates header id\n   */\n\n\n  function Slugger() {\n    this.seen = {};\n  }\n  /**\n   * Convert string to unique id\n   */\n\n\n  Slugger.prototype.slug = function (value) {\n    var slug = value.toLowerCase().trim().replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n\n    if (this.seen.hasOwnProperty(slug)) {\n      var originalSlug = slug;\n\n      do {\n        this.seen[originalSlug]++;\n        slug = originalSlug + '-' + this.seen[originalSlug];\n      } while (this.seen.hasOwnProperty(slug));\n    }\n\n    this.seen[slug] = 0;\n    return slug;\n  };\n  /**\n   * Helpers\n   */\n\n\n  function escape(html, encode) {\n    if (encode) {\n      if (escape.escapeTest.test(html)) {\n        return html.replace(escape.escapeReplace, function (ch) {\n          return escape.replacements[ch];\n        });\n      }\n    } else {\n      if (escape.escapeTestNoEncode.test(html)) {\n        return html.replace(escape.escapeReplaceNoEncode, function (ch) {\n          return escape.replacements[ch];\n        });\n      }\n    }\n\n    return html;\n  }\n\n  escape.escapeTest = /[&<>\"']/;\n  escape.escapeReplace = /[&<>\"']/g;\n  escape.replacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n  escape.escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  escape.escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n\n  function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  function edit(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    return {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(/(^|[^\\[])\\^/g, '$1');\n        regex = regex.replace(name, val);\n        return this;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n  }\n\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      try {\n        var prot = decodeURIComponent(unescape(href)).replace(/[^\\w:]/g, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (/^[^:]+:\\/*[^/]*$/.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n\n    if (href.slice(0, 2) === '//') {\n      return base.replace(/:[\\s\\S]*/, ':') + href;\n    } else if (href.charAt(0) === '/') {\n      return base.replace(/(:\\/*[^/]*)[\\s\\S]*/, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var baseUrls = {};\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function noop() {}\n\n  noop.exec = noop;\n\n  function merge(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/),\n        i = 0;\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim(str, c, invert) {\n    if (str.length === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < str.length) {\n      var currChar = str.charAt(str.length - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, str.length - suffLen);\n  }\n\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var level = 0;\n\n    for (var i = 0; i < str.length; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Marked\n   */\n\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (callback || typeof opt === 'function') {\n      if (!callback) {\n        callback = opt;\n        opt = null;\n      }\n\n      opt = merge({}, marked.defaults, opt || {});\n      var highlight = opt.highlight,\n          tokens,\n          pending,\n          i = 0;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      pending = tokens.length;\n\n      var done = function done(err) {\n        if (err) {\n          opt.highlight = highlight;\n          return callback(err);\n        }\n\n        var out;\n\n        try {\n          out = Parser.parse(tokens, opt);\n        } catch (e) {\n          err = e;\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!pending) return done();\n\n      for (; i < tokens.length; i++) {\n        (function (token) {\n          if (token.type !== 'code') {\n            return --pending || done();\n          }\n\n          return highlight(token.text, token.lang, function (err, code) {\n            if (err) return done(err);\n\n            if (code == null || code === token.text) {\n              return --pending || done();\n            }\n\n            token.text = code;\n            token.escaped = true;\n            --pending || done();\n          });\n        })(tokens[i]);\n      }\n\n      return;\n    }\n\n    try {\n      if (opt) opt = merge({}, marked.defaults, opt);\n      return Parser.parse(Lexer.lex(src, opt), opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if ((opt || marked.defaults).silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge(marked.defaults, opt);\n    return marked;\n  };\n\n  marked.getDefaults = function () {\n    return {\n      baseUrl: null,\n      breaks: false,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: '',\n      highlight: null,\n      langPrefix: 'language-',\n      mangle: true,\n      pedantic: false,\n      renderer: new Renderer(),\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartLists: false,\n      smartypants: false,\n      tables: true,\n      xhtml: false\n    };\n  };\n\n  marked.defaults = marked.getDefaults();\n  /**\n   * Expose\n   */\n\n  marked.Parser = Parser;\n  marked.parser = Parser.parse;\n  marked.Renderer = Renderer;\n  marked.TextRenderer = TextRenderer;\n  marked.Lexer = Lexer;\n  marked.lexer = Lexer.lex;\n  marked.InlineLexer = InlineLexer;\n  marked.inlineLexer = InlineLexer.output;\n  marked.Slugger = Slugger;\n  marked.parse = marked;\n\n  if (typeof module !== 'undefined' && typeof exports === 'object') {\n    module.exports = marked;\n  } else if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return marked;\n    });\n  } else {\n    root.marked = marked;\n  }\n})(this || (typeof window !== 'undefined' ? window : global));"],"sourceRoot":""}